<script>
    var lastStatus = null;
    var coreData = [];
    var diagData = {};

    var lastResult = null;

    function compareReadingsByTimestamp(a, b) {
        var dt_a = getDateFromISO(a.timestamp_packet);
        var dt_b = getDateFromISO(b.timestamp_packet);
        if (dt_a > dt_b) {
            return -1;
        }
        else if (dt_a < dt_b) {
            return 1;
        }
        return 0;
    }

    function updateSingleTag(tag, index) {
        var element;
        if (coreData.length <= index) {
                element = tag;
                element.id = index;
                element.display = {};
                coreData.push(element);
                element.readings.sort(compareReadingsByTimestamp);
                return element;
        }
        else if (coreData[index].name != tag.name) {
            element = null;
            for (i=0; i<coreData.length; i++) {
                if (coreData[i].name == tag.name) {
                    index = i;
                    element = coreData[i];
                    break;
                }
            }
            if (element == null) {
                element = tag;
                element.id = index;
                element.display = {};
                coreData.push(element);
                element.readings.sort(compareReadingsByTimestamp);
                return element;
            }
        }
        else {
            element = coreData[index];
        }
        var addedReading = 0;
        for (i=0; i<tag.readings.length; i++) {
            var alreadyExists = false;
            for (j=0; j<element.readings.length; j++) {
                if (element.readings[j].timestamp_packet == tag.readings[i].timestamp_packet) {
                    alreadyExists = true;
                    element.readings[j] = tag.readings[i]
                    break;
                }
            }
            if (!alreadyExists) {
                element.readings.push(tag.readings[i]);
                addedReading++;
            }
        }
        if (addedReading > 0) {
            element.readings.sort(compareReadingsByTimestamp);
        }
        return element;
    }

    function processSingleTag(tag) {
        var dsp = {
            received: "--",
            updated: "--",
            reading: "--",
            alert_state: "",
            trend_24h: "",
            speed_24h: "",
            max_24h: "",
            min_24h: "",
            avg_24h: "",
            enabled_24h: false,
            trend_3h: "",
            speed_3h: "",
            max_3h: "",
            min_3h: "",
            avg_3h: "",
            enabled_3h: false,
        }
        if (tag.readings.length>0) {
            dsp.received = getTimeFromNow(tag.readings[0].timestamp_packet, "Последнее изменение");
            dsp.updated = getTimeFromNow(tag.readings[0].timestamp_receive, "Обновлено");
            dsp.reading = tag.readings[0].reading + " " + tag.units;
            tag.enabled = true
            if (tag.readings[0].limits != null) {
                // Limits
                dsp.limit = tag.readings[0].limits.state;
                if (dsp.limit == "very_high" || dsp.limit == "very_low") {
                    dsp.alert_state = "danger";
                }
                else if (dsp.limit != "normal" || dsp.limit == "low") {
                    dsp.alert_state = "warning";
                }
            }
            if (tag.readings[0].trends != null) {
                // Trends
                for (i=0; i<tag.readings[0].trends.length; i++) {
                    var currentTrend = tag.readings[0].trends[i];
                    if (currentTrend == null || (currentTrend.error != undefined && currentTrend.error != "")) {
                        continue;
                    }
                    if (currentTrend.period_seconds == 86400) {
                        dsp.trend_24h = currentTrend.direction;
                        if (dsp.trend_24h == "increase" || dsp.trend_24h == "decrease") {
                            dsp.speed_24h = (currentTrend.slope * 3600).toFixed(2);
                        }
                        dsp.max_24h = currentTrend.peak_max.reading.toFixed(2);
                        dsp.max_24h_time = new Date(getDateFromISO(currentTrend.peak_max.time));
                        dsp.min_24h = currentTrend.peak_min.reading.toFixed(2);
                        dsp.min_24h_time = new Date(getDateFromISO(currentTrend.peak_min.time));
                        dsp.avg_24h = currentTrend.average.reading.toFixed(2);
                        dsp.num_24h = currentTrend.number;
                        dsp.enabled_24h = true;
                        continue;
                    }
                    if (currentTrend.period_seconds == 10800) {
                        dsp.trend_3h = currentTrend.direction;
                        if (dsp.trend_3h == "increase" || dsp.trend_3h == "decrease") {
                            dsp.speed_3h = (currentTrend.slope * 3600).toFixed(2);
                        }
                        dsp.max_3h = currentTrend.peak_max.reading.toFixed(2);
                        dsp.max_3h_time = new Date(getDateFromISO(currentTrend.peak_max.time));
                        dsp.min_3h = currentTrend.peak_min.reading.toFixed(2);
                        dsp.min_3h_time = new Date(getDateFromISO(currentTrend.peak_min.time));
                        dsp.avg_3h = currentTrend.average.reading.toFixed(2);
                        dsp.num_3h = currentTrend.number;
                        dsp.enabled_3h = true;
                        continue;
                    }
                }
            }
        }
        else {
            dsp.reading = "--";
            tag.current_t_packet = null;
            tag.current_t_receive = null;
            tag.enabled = false;
            dsp.enabled_24h = false;
        }
        tag.display = dsp;
    }


    function processCoreData(response, status) {
        lastResult = response;
        if (response.hasOwnProperty('error')) {
            diagData.error = response.error;
            return;
        } 
        diagData.obtain_timing = response.time_to_obtain;
        for (k=0; k<response.tags.length; k++) {
            var element = updateSingleTag(response.tags[k], k);
            processSingleTag(element);
        }
        diagData.request_in_progress = false;
        finDate = new Date();
        diagData.request_timing = (finDate - stDate)/1000;
        console.log("Finished request in " + diagData.time_to_request + " seconds");     
    }
</script>